### 现代计算机使用冯诺依曼架构
> [计算机架构到底是个什么样子的？ - OFweek智能制造网](https://m.ofweek.com/im/2020-12/ART-201928-11000-30472604.html)
#### 冯诺依曼架构
冯诺依曼的核心是：「存储程序，顺序执行」，规定计算机必须具有如下功能：
把需要的程序和数据送至计算机中；必须具有长期记忆程序、数据、中间结果及最终运算结果的能力；能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力；能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；能够按照要求将处理结果输出给用户
#### 哈佛架构
冯诺依曼结构和哈佛结构是有区别的。
冯诺依曼结构是程序存储区和数据存储器都是可以放到内存中，统一编码的，而哈弗结构是分开编址的。
#### 哪些处理器是哈佛架构、冯诺依曼架构
「哈佛架构」
MCU（单片机）几乎都是用哈佛结构，譬如广泛使用的51单片机、典型的STM32单片机（核心是ARM Cortex－M系列的）都是哈佛结构。
「冯诺依曼架构」
PC和服务器芯片（譬如Intel AMD），ARM Cortex－A系列嵌入式芯片（譬如核心是ARM Cortex－A9的三星exynos－4412，譬如华为的麒麟970等手机芯片）等都是冯诺依曼结构。这些系统都需要大量内存，所以工作内存都是DRAM，因为他们更适合使用冯诺依曼系统。
「混合结构」
实际上现代的CPU（准确说叫SoC）基本都不是纯粹的哈佛结构或冯诺依曼机构，而都是混合结构的。
比如三星exynos 4412，使用ARM的Cortex－A9核心。基于exynos 4412开发板上都配备了1024MB的DDR SDRAM，和8GB的EMMC。
正常工作时所有的程序和数据都从EMMC中加载到DDR中，也就是说不管你是指令还是数据，存储都是在EMMC中，运行时都在DDR中，再通过cache和寄存器送给CPU去加工处理。这就是典型的冯诺依曼系统。
但是，exynos 4412内部仍然有一定容量的64KB irom和64KB iram，这些irom和iram是用于SoC引导和启动的，芯片上电后首先会执行内部irom中固化的代码，其实执行这些代码时4412就好像一个MCU一样，irom就是他的flash，iram就是他的SRAM，这又是典型的哈佛结构。
### 计算机中的存储器唯一可以存储的形式是比特
计算机中的存储器唯一可以存储的形式是比特，因此如果想在计算机上处理信息，就必须把它们转换为比特的形式来存储。我们已经掌握了如何用比特来表示数字和机器码。如何用它来存储文本呢？毕竞，人类所积累的大部分信息，都以各种文本形式保存的。下面就轮到ASCⅡ码出场了！
### 摩尔斯电码
> [摩尔斯电码 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81)

摩尔斯电码是一种早期的[数字化](https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E5%8C%96 "数字化")通信形式，但是它不同于现代只使用0和1两种状态的[二进制](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6 "二进制")代码，它的代码包括五种：
1. [点](https://zh.wikipedia.org/wiki/%E7%82%B9 "点")（`·`）：1
2. [划](https://zh.wikipedia.org/wiki/%E9%80%A3%E6%8E%A5%E8%99%9F "连接号")（`-`）：111
3. [字符](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6 "字符")内部的停顿（在点和划之间）：0
4. 字符之间的停顿：000
5. [单词](https://zh.wikipedia.org/wiki/%E5%8D%95%E8%AF%8D "单词")之间的停顿：0000000
发送参考：
![[assets/Pasted image 20240921152547.png]]
接收参考：二叉树表示的国际摩尔斯电码。图中每一分叉的左支为点（`·`），右支为划（`-`），直到到达所需要表示的字符为止。
![[assets/Pasted image 20240921155255.png]]

- 一个划的时长是点的3倍，单词之间则通过相当于两个“划”的时长来分隔（7个也差不多）
- 乍一看，莫尔斯编码的定义与打字机字母的排列一样都是随意的。这里的定义是指字母表中的字母与各种“点”和“划”的组合序列之间的对应关系。然而，仔细研究之后，我们就会发现事实并非完全如此。简单且短促的编码，被分配给字母表中使用频率较高的字母，例如E和T。拼字比赛选手和“幸运轮”的粉丝们可能会很快意识到这一点。而不太常用的字母，比如Q和Z（这只会让选手在拼字中得到10分）则被分配以较长的编码。
- 莫尔斯编码的一个缺点是，它没有区分大写字母和小写字母。
- [SOS](https://zh.wikipedia.org/wiki/SOS "SOS")   `···---···`    求救信号。
- 当你和朋友最终熟记了莫尔斯编码之后(这是能熟练地收发编码的唯一方法)，你们甚至可以在口语中使用它，用来取代正常的语言。为了使编码发送的速度最快，你可以把“点”读作“嘀（dib”，把“划”读作“嗒（dab”。文字也可以用同样的方式简化成“点”和“划”的序列，莫尔斯编码的口语版把讲话内容缩减到只剩下两个声音了。
- 两种闪烁，两种声音。事实上，两个不同的事物，只要经过适当的组合，就可以表示所有类型的信息，这的确是千真万确的。
### 编码就是交流
编码这个词的意思是指一种用来在机器和人之间传递信息的方式。换句话说，编码就是交流。有时候我们认为编码就是指秘密的东西（密码）。但是大部分编码不是这样的。毕竟，大部分编码必须易于理解，因为它们是人类交流的基础。
英语词汇就是一类编码
### 布莱叶盲文
> [盲文 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/%E7%9B%B2%E6%96%87)

盲文的基本单位是长方形的盲符，有位置固定的六个点，每个点可以凸出或不凸出，形成64种可能，而全部不凸出不能表示实际含义，所以通常认为只有63种。六个点的分布是左右两行，上中下三层。如图所示，左行自上而下称为1、2、3点，右行自上而下称为4、5、6点。
![[assets/Pasted image 20240921160142.png]]
第一行只用第1、2、4、5四个点，第二行由第一行加第3点而得，第三行除“w”外，其余（即“uvxyz”）均由第一行（即“abcde”）加第3、6点而得，“w”则由第一行的“j”加第6点而得。第一行十个字母的符形也有一定规律，前三个字母（abc）和元音字母（aei）只有一个或两个凸点，第4、6、8、10个字母（dfhj）有三个凸点，剩下的g有四个凸点。
特性是1必须有点，如果没有就是2和4必须有点，这样可以让盲人阅读时有一个原点来判断相对位置。
![[assets/Pasted image 20240921160219.png]]
### 白炽灯
灯泡里面有一根很细的金属丝，我们称它为灯丝，一般情况下灯丝是用钨制作的。灯丝的一端连在灯泡底座的凸起上，另一端连到金属底座上，金属底座与凸起之间被绝缘层隔开。金属丝的电阻使它开始发热。如果暴露在空气中，钨丝将达到燃点并开始燃烧，但是在灯泡的真空泡室内，钨丝就会发出光亮。
1. 白炽灯外形轮廓。
2. 低压惰性气体。
3. 灯丝，钨丝。
4. 细金属线（连接至灯头尖端）
5. 细金属线（连接至铜片）
6. 支撑金属线
7. 支撑棒
8. 细金属线
9. 铜片
10. 绝缘体
11. 灯头尖端
![[assets/Pasted image 20240921170504.png]]
### 硬拷贝
基本意思：
当资料经由打印机输出至纸上称为硬拷贝，若资料显示在荧幕上则称为软拷贝。
计算机中：
1. 硬拷贝和软拷贝
硬拷贝：创建一个完全独立的新对象，包括所有数据成员。
软拷贝：创建一个新对象，但新对象与原对象共享某些资源（如指针指向的数据）。
2. 深拷贝和浅拷贝
深拷贝：类似于硬拷贝，复制整个对象及其所有成员，包括动态分配的内存。
浅拷贝：类似于软拷贝，只复制对象的基本内容，对于指针成员，只复制指针本身而不复制指向的数据。
应用场景：
1. 硬拷贝/深拷贝：
   - 当需要完全独立的对象副本时使用。
   - 适用于需要修改副本而不影响原对象的情况。
   - 例如：处理包含动态分配内存的复杂数据结构。
2. 软拷贝/浅拷贝：
   - 当对象包含大量数据，且不需要修改这些数据时使用。
   - 用于提高性能和节省内存。
   - 例如：传递大型只读数据结构作为函数参数。
在C++中，默认的复制构造函数和赋值运算符通常执行浅拷贝。如果类包含指针成员，可能需要自定义深拷贝实现。
```cpp
#include <iostream>
#include <cstring>

class ShallowCopy {
public:
    int* data;
    
    ShallowCopy(int val) {
        data = new int(val);
    }
    
    // 默认复制构造函数（浅拷贝）
    // Default copy constructor (shallow copy)
};

class DeepCopy {
public:
    int* data;
    
    DeepCopy(int val) {
        data = new int(val);
    }
    
    // 自定义复制构造函数（深拷贝）
    // Custom copy constructor (deep copy)
    DeepCopy(const DeepCopy& other) {
        data = new int(*other.data);
    }
    
    ~DeepCopy() {
        delete data;
    }
};

class StringWrapper {
public:
    char* str;
    
    StringWrapper(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }
    
    // 深拷贝构造函数
    // Deep copy constructor
    StringWrapper(const StringWrapper& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }
    
    // 移动构造函数（高效的"深拷贝"）
    // Move constructor (efficient "deep copy")
    StringWrapper(StringWrapper&& other) noexcept {
        str = other.str;
        other.str = nullptr;
    }
    
    ~StringWrapper() {
        delete[] str;
    }
};

int main() {
    // 浅拷贝示例
    // Shallow copy example
    ShallowCopy shallow1(5);
    ShallowCopy shallow2 = shallow1;  // 浅拷贝
    *shallow2.data = 10;
    std::cout << "Shallow copy: " << *shallow1.data << ", " << *shallow2.data << std::endl;
    
    // 深拷贝示例
    // Deep copy example
    DeepCopy deep1(5);
    DeepCopy deep2 = deep1;  // 深拷贝
    *deep2.data = 10;
    std::cout << "Deep copy: " << *deep1.data << ", " << *deep2.data << std::endl;
    
    // 字符串包装器示例
    // String wrapper example
    StringWrapper str1("Hello");
    StringWrapper str2 = str1;  // 深拷贝
    StringWrapper str3 = std::move(str1);  // 移动（高效的"深拷贝"）
    
    std::cout << "Original: " << str2.str << std::endl;
    std::cout << "Moved: " << (str3.str ? str3.str : "null") << std::endl;
    std::cout << "After move: " << (str1.str ? str1.str : "null") << std::endl;
    
    return 0;
}
```

这个代码示例展示了浅拷贝、深拷贝和移动语义的概念。
1. `ShallowCopy` 类：
   - 使用默认的复制构造函数，执行浅拷贝。
   - 当复制对象时，只复制指针，而不是指针指向的数据。
2. `DeepCopy` 类：
   - 实现了自定义的复制构造函数，执行深拷贝。
   - 复制时，不仅复制指针，还创建新的内存并复制数据。
3. `StringWrapper` 类：
   - 展示了更复杂的深拷贝场景（处理动态分配的字符数组）。
   - 实现了深拷贝构造函数和移动构造函数。
4. 在 `main()` 函数中：
   - 演示了浅拷贝可能导致的问题（修改一个对象会影响另一个）。
   - 展示了深拷贝如何创建独立的对象副本。
   - 说明了移动语义如何实现高效的资源转移。
这些例子说明：
- 浅拷贝适用于简单对象或共享资源的场景。
- 深拷贝适用于需要完全独立副本的情况，特别是涉及动态内存管理时。
- 移动语义可以在某些情况下替代深拷贝，提高效率。
### 数学是我们平常所能接触到的一种最抽象的编码
### 以10为基数或使用十进制数字系统完全是随意的
### 罗马数字
![[assets/Pasted image 20240921180737.png]]
- 字母I表示1，可以看做是一个划线或者一根伸出的手指。
- 字母V像一只手，表示5。
- 两个V是一个X,代表数字10.
- L是50.C来自单词centum,表示100.
- D是500。
- M来自于拉丁文mille,意为1000。
